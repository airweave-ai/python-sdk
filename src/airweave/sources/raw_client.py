# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.not_found_error import NotFoundError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.not_found_error_response import NotFoundErrorResponse
from ..types.rate_limit_error_response import RateLimitErrorResponse
from ..types.source import Source


class RawSourcesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[typing.List[Source]]:
        """
        Retrieve all available data source connectors.

        Returns the complete catalog of source types that Airweave can connect to,
        including their authentication methods, configuration requirements, and
        supported features. Use this endpoint to discover which integrations are
        available for your organization.

        Each source includes:
        - **Authentication methods**: How to connect (OAuth, API key, etc.)
        - **Configuration schemas**: What settings are required or optional
        - **Supported auth providers**: Pre-configured OAuth providers available

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Source]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "sources",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Source],
                    parse_obj_as(
                        type_=typing.List[Source],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(self, short_name: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[Source]:
        """
        Retrieve detailed information about a specific data source connector.

        Returns the complete configuration for a source type, including:

        - **Authentication fields**: Schema for credentials required to connect
        - **Configuration fields**: Schema for optional settings and customization
        - **Supported auth providers**: Pre-configured OAuth providers available for this source

        Use this endpoint before creating a source connection to understand what
        authentication and configuration values are required.

        Parameters
        ----------
        short_name : str
            Technical identifier of the source type (e.g., 'github', 'stripe', 'slack')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Source]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sources/{jsonable_encoder(short_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Source,
                    parse_obj_as(
                        type_=Source,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawSourcesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[Source]]:
        """
        Retrieve all available data source connectors.

        Returns the complete catalog of source types that Airweave can connect to,
        including their authentication methods, configuration requirements, and
        supported features. Use this endpoint to discover which integrations are
        available for your organization.

        Each source includes:
        - **Authentication methods**: How to connect (OAuth, API key, etc.)
        - **Configuration schemas**: What settings are required or optional
        - **Supported auth providers**: Pre-configured OAuth providers available

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Source]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sources",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Source],
                    parse_obj_as(
                        type_=typing.List[Source],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, short_name: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Source]:
        """
        Retrieve detailed information about a specific data source connector.

        Returns the complete configuration for a source type, including:

        - **Authentication fields**: Schema for credentials required to connect
        - **Configuration fields**: Schema for optional settings and customization
        - **Supported auth providers**: Pre-configured OAuth providers available for this source

        Use this endpoint before creating a source connection to understand what
        authentication and configuration values are required.

        Parameters
        ----------
        short_name : str
            Technical identifier of the source type (e.g., 'github', 'stripe', 'slack')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Source]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sources/{jsonable_encoder(short_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Source,
                    parse_obj_as(
                        type_=Source,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
