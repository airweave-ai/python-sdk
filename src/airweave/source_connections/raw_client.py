# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.conflict_error import ConflictError
from ..errors.not_found_error import NotFoundError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.conflict_error_response import ConflictErrorResponse
from ..types.not_found_error_response import NotFoundErrorResponse
from ..types.rate_limit_error_response import RateLimitErrorResponse
from ..types.schedule_config import ScheduleConfig
from ..types.source_connection import SourceConnection
from ..types.source_connection_job import SourceConnectionJob
from ..types.source_connection_list_item import SourceConnectionListItem
from .types.authentication import Authentication

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawSourceConnectionsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        collection: typing.Optional[str] = None,
        skip: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[SourceConnectionListItem]]:
        """
        Retrieve all source connections for your organization.

        Returns a lightweight list of source connections with essential fields for
        display and navigation. Use the collection filter to see connections within
        a specific collection.

        For full connection details including sync history, use the GET /{id} endpoint.

        Parameters
        ----------
        collection : typing.Optional[str]
            Filter by collection readable ID

        skip : typing.Optional[int]
            Number of connections to skip for pagination

        limit : typing.Optional[int]
            Maximum number of connections to return (1-1000)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[SourceConnectionListItem]]
            List of source connections
        """
        _response = self._client_wrapper.httpx_client.request(
            "source-connections",
            method="GET",
            params={
                "collection": collection,
                "skip": skip,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[SourceConnectionListItem],
                    parse_obj_as(
                        type_=typing.List[SourceConnectionListItem],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        short_name: str,
        readable_collection_id: str,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        schedule: typing.Optional[ScheduleConfig] = OMIT,
        sync_immediately: typing.Optional[bool] = OMIT,
        authentication: typing.Optional[Authentication] = OMIT,
        redirect_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SourceConnection]:
        """
        Create a new source connection to sync data from an external source.

        The authentication method determines the creation flow:

        - **Direct**: Provide credentials (API key, token) directly. Connection is created immediately.
        - **OAuth Browser**: Returns a connection with an `auth_url` to redirect users for authentication.
        - **OAuth Token**: Provide an existing OAuth token. Connection is created immediately.
        - **Auth Provider**: Use a pre-configured auth provider (e.g., Composio, Pipedream).

        After successful authentication, data sync can begin automatically or on-demand.

        Parameters
        ----------
        short_name : str
            Source type identifier (e.g., 'slack', 'github', 'notion')

        readable_collection_id : str
            The readable ID of the collection to add this connection to

        name : typing.Optional[str]
            Display name for the connection. If not provided, defaults to '{Source Name} Connection'.

        description : typing.Optional[str]
            Optional description of what this connection is used for

        config : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Source-specific configuration (e.g., repository name, filters)

        schedule : typing.Optional[ScheduleConfig]
            Optional sync schedule configuration

        sync_immediately : typing.Optional[bool]
            Run initial sync after creation. Defaults to True for direct/token/auth_provider, False for OAuth browser/BYOC flows (which sync after authentication)

        authentication : typing.Optional[Authentication]
            Authentication configuration. Type is auto-detected from provided fields.

        redirect_url : typing.Optional[str]
            URL to redirect to after OAuth flow completes (only used for OAuth flows)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SourceConnection]
            Created source connection
        """
        _response = self._client_wrapper.httpx_client.request(
            "source-connections",
            method="POST",
            json={
                "name": name,
                "short_name": short_name,
                "readable_collection_id": readable_collection_id,
                "description": description,
                "config": config,
                "schedule": convert_and_respect_annotation_metadata(
                    object_=schedule, annotation=ScheduleConfig, direction="write"
                ),
                "sync_immediately": sync_immediately,
                "authentication": convert_and_respect_annotation_metadata(
                    object_=authentication, annotation=Authentication, direction="write"
                ),
                "redirect_url": redirect_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnection,
                    parse_obj_as(
                        type_=SourceConnection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(
        self, source_connection_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SourceConnection]:
        """
        Retrieve details of a specific source connection.

        Returns complete information about the connection including:
        - Configuration settings
        - Authentication status
        - Sync schedule and history
        - Entity statistics

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection (UUID)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SourceConnection]
            Source connection details
        """
        _response = self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnection,
                    parse_obj_as(
                        type_=SourceConnection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self, source_connection_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SourceConnection]:
        """
        Permanently delete a source connection and all its synced data.

        **What happens when you delete:**

        1. Any running sync is cancelled and the API waits (up to 15 s) for the
           worker to stop writing.
        2. The source connection, sync configuration, job history, and entity
           metadata are cascade-deleted from the database.
        3. A background cleanup workflow is scheduled to remove data from the
           vector database (Vespa) and raw data storage (ARF). This may take
           several minutes for large datasets but does **not** block the response.

        The API returns immediately after step 2. Vector database cleanup happens
        asynchronously -- the data becomes unsearchable as soon as the database
        records are deleted.

        **Warning**: This action cannot be undone.

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection to delete (UUID)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SourceConnection]
            Deleted source connection
        """
        _response = self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnection,
                    parse_obj_as(
                        type_=SourceConnection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        source_connection_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        schedule: typing.Optional[ScheduleConfig] = OMIT,
        authentication: typing.Optional[Authentication] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SourceConnection]:
        """
        Update an existing source connection's configuration.

        You can modify:
        - **Name and description**: Display information
        - **Configuration**: Source-specific settings (e.g., repository name, filters)
        - **Schedule**: Cron expression for automatic syncs
        - **Authentication**: Update credentials (direct auth only)

        Only include the fields you want to change; omitted fields retain their current values.

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection to update (UUID)

        name : typing.Optional[str]
            Updated display name for the connection

        description : typing.Optional[str]
            Updated description

        config : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Updated source-specific configuration

        schedule : typing.Optional[ScheduleConfig]
            Updated sync schedule configuration

        authentication : typing.Optional[Authentication]
            Updated authentication credentials (direct auth only)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SourceConnection]
            Updated source connection
        """
        _response = self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "config": config,
                "schedule": convert_and_respect_annotation_metadata(
                    object_=schedule, annotation=ScheduleConfig, direction="write"
                ),
                "authentication": convert_and_respect_annotation_metadata(
                    object_=authentication, annotation=Authentication, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnection,
                    parse_obj_as(
                        type_=SourceConnection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def run(
        self,
        source_connection_id: str,
        *,
        force_full_sync: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SourceConnectionJob]:
        """
        Trigger a data synchronization job for a source connection.

        Starts an asynchronous sync job that pulls the latest data from the connected
        source. The job runs in the background and you can monitor its progress using
        the jobs endpoint.

        For continuous sync connections, this performs an incremental sync by default.
        Use `force_full_sync=true` to perform a complete re-sync of all data.

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection to sync (UUID)

        force_full_sync : typing.Optional[bool]
            Force a full sync ignoring cursor data. Only applies to continuous sync connections. Non-continuous connections always perform full syncs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SourceConnectionJob]
            Created sync job
        """
        _response = self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}/run",
            method="POST",
            params={
                "force_full_sync": force_full_sync,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnectionJob,
                    parse_obj_as(
                        type_=SourceConnectionJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ConflictErrorResponse,
                        parse_obj_as(
                            type_=ConflictErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_source_connection_jobs(
        self,
        source_connection_id: str,
        *,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[SourceConnectionJob]]:
        """
        Retrieve the sync job history for a source connection.

        Returns a list of sync jobs ordered by creation time (newest first). Each job
        includes status, timing information, and entity counts.

        Job statuses:
        - **PENDING**: Job is queued, waiting for the worker to pick it up
        - **RUNNING**: Sync is actively pulling and processing data
        - **COMPLETED**: Sync finished successfully
        - **FAILED**: Sync encountered an unrecoverable error
        - **CANCELLING**: Cancellation has been requested. The worker is
          gracefully stopping the pipeline and cleaning up destination data.
        - **CANCELLED**: Sync was cancelled. The worker has fully stopped
          and destination data cleanup has been scheduled.

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection (UUID)

        limit : typing.Optional[int]
            Maximum number of jobs to return (1-1000)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[SourceConnectionJob]]
            List of sync jobs
        """
        _response = self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}/jobs",
            method="GET",
            params={
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[SourceConnectionJob],
                    parse_obj_as(
                        type_=typing.List[SourceConnectionJob],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def cancel_job(
        self, source_connection_id: str, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SourceConnectionJob]:
        """
        Request cancellation of a running sync job.

        **State lifecycle**: `PENDING` / `RUNNING` → `CANCELLING` → `CANCELLED`

        1. The API immediately marks the job as **CANCELLING** in the database.
        2. A cancellation signal is sent to the Temporal workflow.
        3. The worker receives the signal, gracefully stops the sync pipeline
           (cancels worker pool, source stream), and marks the job as **CANCELLED**.

        Already-processed entities are retained in the vector database.
        If the worker is unresponsive, a background cleanup job will force the
        transition to CANCELLED after 3 minutes.

        **Note**: Only jobs in `PENDING` or `RUNNING` state can be cancelled.
        Attempting to cancel a `COMPLETED`, `FAILED`, or `CANCELLED` job returns 400.

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection (UUID)

        job_id : str
            Unique identifier of the sync job to cancel (UUID)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SourceConnectionJob]
            Job with cancellation status
        """
        _response = self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}/jobs/{jsonable_encoder(job_id)}/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnectionJob,
                    parse_obj_as(
                        type_=SourceConnectionJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ConflictErrorResponse,
                        parse_obj_as(
                            type_=ConflictErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawSourceConnectionsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        collection: typing.Optional[str] = None,
        skip: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[SourceConnectionListItem]]:
        """
        Retrieve all source connections for your organization.

        Returns a lightweight list of source connections with essential fields for
        display and navigation. Use the collection filter to see connections within
        a specific collection.

        For full connection details including sync history, use the GET /{id} endpoint.

        Parameters
        ----------
        collection : typing.Optional[str]
            Filter by collection readable ID

        skip : typing.Optional[int]
            Number of connections to skip for pagination

        limit : typing.Optional[int]
            Maximum number of connections to return (1-1000)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[SourceConnectionListItem]]
            List of source connections
        """
        _response = await self._client_wrapper.httpx_client.request(
            "source-connections",
            method="GET",
            params={
                "collection": collection,
                "skip": skip,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[SourceConnectionListItem],
                    parse_obj_as(
                        type_=typing.List[SourceConnectionListItem],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        short_name: str,
        readable_collection_id: str,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        schedule: typing.Optional[ScheduleConfig] = OMIT,
        sync_immediately: typing.Optional[bool] = OMIT,
        authentication: typing.Optional[Authentication] = OMIT,
        redirect_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SourceConnection]:
        """
        Create a new source connection to sync data from an external source.

        The authentication method determines the creation flow:

        - **Direct**: Provide credentials (API key, token) directly. Connection is created immediately.
        - **OAuth Browser**: Returns a connection with an `auth_url` to redirect users for authentication.
        - **OAuth Token**: Provide an existing OAuth token. Connection is created immediately.
        - **Auth Provider**: Use a pre-configured auth provider (e.g., Composio, Pipedream).

        After successful authentication, data sync can begin automatically or on-demand.

        Parameters
        ----------
        short_name : str
            Source type identifier (e.g., 'slack', 'github', 'notion')

        readable_collection_id : str
            The readable ID of the collection to add this connection to

        name : typing.Optional[str]
            Display name for the connection. If not provided, defaults to '{Source Name} Connection'.

        description : typing.Optional[str]
            Optional description of what this connection is used for

        config : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Source-specific configuration (e.g., repository name, filters)

        schedule : typing.Optional[ScheduleConfig]
            Optional sync schedule configuration

        sync_immediately : typing.Optional[bool]
            Run initial sync after creation. Defaults to True for direct/token/auth_provider, False for OAuth browser/BYOC flows (which sync after authentication)

        authentication : typing.Optional[Authentication]
            Authentication configuration. Type is auto-detected from provided fields.

        redirect_url : typing.Optional[str]
            URL to redirect to after OAuth flow completes (only used for OAuth flows)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SourceConnection]
            Created source connection
        """
        _response = await self._client_wrapper.httpx_client.request(
            "source-connections",
            method="POST",
            json={
                "name": name,
                "short_name": short_name,
                "readable_collection_id": readable_collection_id,
                "description": description,
                "config": config,
                "schedule": convert_and_respect_annotation_metadata(
                    object_=schedule, annotation=ScheduleConfig, direction="write"
                ),
                "sync_immediately": sync_immediately,
                "authentication": convert_and_respect_annotation_metadata(
                    object_=authentication, annotation=Authentication, direction="write"
                ),
                "redirect_url": redirect_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnection,
                    parse_obj_as(
                        type_=SourceConnection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, source_connection_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SourceConnection]:
        """
        Retrieve details of a specific source connection.

        Returns complete information about the connection including:
        - Configuration settings
        - Authentication status
        - Sync schedule and history
        - Entity statistics

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection (UUID)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SourceConnection]
            Source connection details
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnection,
                    parse_obj_as(
                        type_=SourceConnection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self, source_connection_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SourceConnection]:
        """
        Permanently delete a source connection and all its synced data.

        **What happens when you delete:**

        1. Any running sync is cancelled and the API waits (up to 15 s) for the
           worker to stop writing.
        2. The source connection, sync configuration, job history, and entity
           metadata are cascade-deleted from the database.
        3. A background cleanup workflow is scheduled to remove data from the
           vector database (Vespa) and raw data storage (ARF). This may take
           several minutes for large datasets but does **not** block the response.

        The API returns immediately after step 2. Vector database cleanup happens
        asynchronously -- the data becomes unsearchable as soon as the database
        records are deleted.

        **Warning**: This action cannot be undone.

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection to delete (UUID)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SourceConnection]
            Deleted source connection
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnection,
                    parse_obj_as(
                        type_=SourceConnection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        source_connection_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        schedule: typing.Optional[ScheduleConfig] = OMIT,
        authentication: typing.Optional[Authentication] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SourceConnection]:
        """
        Update an existing source connection's configuration.

        You can modify:
        - **Name and description**: Display information
        - **Configuration**: Source-specific settings (e.g., repository name, filters)
        - **Schedule**: Cron expression for automatic syncs
        - **Authentication**: Update credentials (direct auth only)

        Only include the fields you want to change; omitted fields retain their current values.

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection to update (UUID)

        name : typing.Optional[str]
            Updated display name for the connection

        description : typing.Optional[str]
            Updated description

        config : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Updated source-specific configuration

        schedule : typing.Optional[ScheduleConfig]
            Updated sync schedule configuration

        authentication : typing.Optional[Authentication]
            Updated authentication credentials (direct auth only)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SourceConnection]
            Updated source connection
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "config": config,
                "schedule": convert_and_respect_annotation_metadata(
                    object_=schedule, annotation=ScheduleConfig, direction="write"
                ),
                "authentication": convert_and_respect_annotation_metadata(
                    object_=authentication, annotation=Authentication, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnection,
                    parse_obj_as(
                        type_=SourceConnection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def run(
        self,
        source_connection_id: str,
        *,
        force_full_sync: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SourceConnectionJob]:
        """
        Trigger a data synchronization job for a source connection.

        Starts an asynchronous sync job that pulls the latest data from the connected
        source. The job runs in the background and you can monitor its progress using
        the jobs endpoint.

        For continuous sync connections, this performs an incremental sync by default.
        Use `force_full_sync=true` to perform a complete re-sync of all data.

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection to sync (UUID)

        force_full_sync : typing.Optional[bool]
            Force a full sync ignoring cursor data. Only applies to continuous sync connections. Non-continuous connections always perform full syncs.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SourceConnectionJob]
            Created sync job
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}/run",
            method="POST",
            params={
                "force_full_sync": force_full_sync,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnectionJob,
                    parse_obj_as(
                        type_=SourceConnectionJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ConflictErrorResponse,
                        parse_obj_as(
                            type_=ConflictErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_source_connection_jobs(
        self,
        source_connection_id: str,
        *,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[SourceConnectionJob]]:
        """
        Retrieve the sync job history for a source connection.

        Returns a list of sync jobs ordered by creation time (newest first). Each job
        includes status, timing information, and entity counts.

        Job statuses:
        - **PENDING**: Job is queued, waiting for the worker to pick it up
        - **RUNNING**: Sync is actively pulling and processing data
        - **COMPLETED**: Sync finished successfully
        - **FAILED**: Sync encountered an unrecoverable error
        - **CANCELLING**: Cancellation has been requested. The worker is
          gracefully stopping the pipeline and cleaning up destination data.
        - **CANCELLED**: Sync was cancelled. The worker has fully stopped
          and destination data cleanup has been scheduled.

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection (UUID)

        limit : typing.Optional[int]
            Maximum number of jobs to return (1-1000)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[SourceConnectionJob]]
            List of sync jobs
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}/jobs",
            method="GET",
            params={
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[SourceConnectionJob],
                    parse_obj_as(
                        type_=typing.List[SourceConnectionJob],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def cancel_job(
        self, source_connection_id: str, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SourceConnectionJob]:
        """
        Request cancellation of a running sync job.

        **State lifecycle**: `PENDING` / `RUNNING` → `CANCELLING` → `CANCELLED`

        1. The API immediately marks the job as **CANCELLING** in the database.
        2. A cancellation signal is sent to the Temporal workflow.
        3. The worker receives the signal, gracefully stops the sync pipeline
           (cancels worker pool, source stream), and marks the job as **CANCELLED**.

        Already-processed entities are retained in the vector database.
        If the worker is unresponsive, a background cleanup job will force the
        transition to CANCELLED after 3 minutes.

        **Note**: Only jobs in `PENDING` or `RUNNING` state can be cancelled.
        Attempting to cancel a `COMPLETED`, `FAILED`, or `CANCELLED` job returns 400.

        Parameters
        ----------
        source_connection_id : str
            Unique identifier of the source connection (UUID)

        job_id : str
            Unique identifier of the sync job to cancel (UUID)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SourceConnectionJob]
            Job with cancellation status
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"source-connections/{jsonable_encoder(source_connection_id)}/jobs/{jsonable_encoder(job_id)}/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourceConnectionJob,
                    parse_obj_as(
                        type_=SourceConnectionJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ConflictErrorResponse,
                        parse_obj_as(
                            type_=ConflictErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
