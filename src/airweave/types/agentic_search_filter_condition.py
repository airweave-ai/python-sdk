# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .agentic_search_filter_operator import AgenticSearchFilterOperator
from .agentic_search_filterable_field import AgenticSearchFilterableField
from .value import Value


class AgenticSearchFilterCondition(UniversalBaseModel):
    """
    A single filter condition.

    Pydantic validates that:
    - ``field`` is a valid AgenticSearchFilterableField enum value
    - ``operator`` is a valid AgenticSearchFilterOperator enum value
    - ``value`` matches the expected types
    - The combination of field + operator + value is semantically valid

    Invalid filters raise ``pydantic.ValidationError`` automatically.

    Examples:
        {"field": "airweave_system_metadata.source_name", "operator": "equals",
         "value": "notion"}
        {"field": "created_at", "operator": "greater_than",
         "value": "2024-01-01T00:00:00Z"}
        {"field": "breadcrumbs.name", "operator": "contains", "value": "Engineering"}
    """

    field: AgenticSearchFilterableField = pydantic.Field()
    """
    Field to filter on (use dot notation for nested fields).
    """

    operator: AgenticSearchFilterOperator = pydantic.Field()
    """
    The comparison operator to use.
    """

    value: Value = pydantic.Field()
    """
    Value to compare against. Use a list for 'in' and 'not_in' operators.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
