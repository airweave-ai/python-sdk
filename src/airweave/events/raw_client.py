# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.enable_endpoint_request import EnableEndpointRequest
from ..types.endpoint_out import EndpointOut
from ..types.endpoint_secret_out import EndpointSecretOut
from ..types.event_type import EventType
from ..types.http_validation_error import HttpValidationError
from ..types.message_attempt_out import MessageAttemptOut
from ..types.message_out import MessageOut
from ..types.recover_out import RecoverOut
from ..types.subscription_with_attempts_out import SubscriptionWithAttemptsOut

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawEventsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_messages(
        self,
        *,
        event_types: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[MessageOut]]:
        """
        Get event messages for the current organization.

        Args:
            ctx: The API context containing organization info.
            event_types: Optional list of event types to filter by.

        Returns:
            List of event messages.

        Parameters
        ----------
        event_types : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[MessageOut]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "events/messages",
            method="GET",
            params={
                "event_types": event_types,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[MessageOut],
                    parse_obj_as(
                        type_=typing.List[MessageOut],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_message(
        self, message_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[MessageOut]:
        """
        Get a specific event message by ID.

        Args:
            message_id: The ID of the message to retrieve.
            ctx: The API context containing organization info.

        Returns:
            The event message with its payload.

        Parameters
        ----------
        message_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[MessageOut]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"events/messages/{jsonable_encoder(message_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MessageOut,
                    parse_obj_as(
                        type_=MessageOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_message_attempts(
        self, message_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[MessageAttemptOut]]:
        """
        Get delivery attempts for a specific message.

        Args:
            message_id: The ID of the message.
            ctx: The API context containing organization info.

        Returns:
            List of delivery attempts for this message.

        Parameters
        ----------
        message_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[MessageAttemptOut]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"events/messages/{jsonable_encoder(message_id)}/attempts",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[MessageAttemptOut],
                    parse_obj_as(
                        type_=typing.List[MessageAttemptOut],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_subscriptions(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[EndpointOut]]:
        """
        Get all webhook subscriptions for the current organization.

        Args:
            ctx: The API context containing organization info.

        Returns:
            List of webhook subscriptions.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[EndpointOut]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "events/subscriptions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[EndpointOut],
                    parse_obj_as(
                        type_=typing.List[EndpointOut],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_subscription(
        self,
        *,
        url: str,
        event_types: typing.Sequence[EventType],
        secret: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EndpointOut]:
        """
        Create a new webhook subscription.

        Args:
            request: The subscription creation request.
            ctx: The API context containing organization info.

        Returns:
            The created subscription.

        Parameters
        ----------
        url : str

        event_types : typing.Sequence[EventType]

        secret : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EndpointOut]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "events/subscriptions",
            method="POST",
            json={
                "url": url,
                "event_types": event_types,
                "secret": secret,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EndpointOut,
                    parse_obj_as(
                        type_=EndpointOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_subscription(
        self, subscription_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SubscriptionWithAttemptsOut]:
        """
        Get a specific webhook subscription with its delivery attempts.

        Args:
            subscription_id: The ID of the subscription to retrieve.
            ctx: The API context containing organization info.

        Returns:
            The subscription details with message delivery attempts.

        Parameters
        ----------
        subscription_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SubscriptionWithAttemptsOut]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SubscriptionWithAttemptsOut,
                    parse_obj_as(
                        type_=SubscriptionWithAttemptsOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_subscription(
        self, subscription_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Delete a webhook subscription.

        Args:
            subscription_id: The ID of the subscription to delete.
            ctx: The API context containing organization info.

        Parameters
        ----------
        subscription_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def patch_subscription(
        self,
        subscription_id: str,
        *,
        url: typing.Optional[str] = OMIT,
        event_types: typing.Optional[typing.Sequence[EventType]] = OMIT,
        disabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EndpointOut]:
        """
        Update a webhook subscription.

        Args:
            subscription_id: The ID of the subscription to update.
            request: The subscription update request.
            ctx: The API context containing organization info.

        Returns:
            The updated subscription.

        Parameters
        ----------
        subscription_id : str

        url : typing.Optional[str]

        event_types : typing.Optional[typing.Sequence[EventType]]

        disabled : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EndpointOut]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}",
            method="PATCH",
            json={
                "url": url,
                "event_types": event_types,
                "disabled": disabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EndpointOut,
                    parse_obj_as(
                        type_=EndpointOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def enable_subscription(
        self,
        subscription_id: str,
        *,
        request: typing.Optional[EnableEndpointRequest] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EndpointOut]:
        """
        Enable a disabled webhook subscription, optionally recovering failed messages.

        Args:
            subscription_id: The ID of the subscription to enable.
            request: Optional request with recovery time range.
            ctx: The API context containing organization info.

        Returns:
            The enabled subscription.

        Parameters
        ----------
        subscription_id : str

        request : typing.Optional[EnableEndpointRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EndpointOut]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}/enable",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=EnableEndpointRequest, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EndpointOut,
                    parse_obj_as(
                        type_=EndpointOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_subscription_secret(
        self, subscription_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[EndpointSecretOut]:
        """
        Get the signing secret for a webhook subscription.

        Args:
            subscription_id: The ID of the subscription.
            ctx: The API context containing organization info.

        Returns:
            The subscription's signing secret.

        Parameters
        ----------
        subscription_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EndpointSecretOut]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}/secret",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EndpointSecretOut,
                    parse_obj_as(
                        type_=EndpointSecretOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def recover_failed_messages(
        self,
        subscription_id: str,
        *,
        since: dt.datetime,
        until: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RecoverOut]:
        """
        Recover (retry) failed messages for a webhook subscription.

        This endpoint triggers a recovery of all failed messages since the specified
        time. Useful after re-enabling a disabled endpoint to retry messages that
        failed while the endpoint was down.

        Args:
            subscription_id: The ID of the subscription to recover messages for.
            request: The recovery request with time range.
            ctx: The API context containing organization info.

        Returns:
            Information about the recovery task.

        Parameters
        ----------
        subscription_id : str

        since : dt.datetime

        until : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RecoverOut]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}/recover",
            method="POST",
            json={
                "since": since,
                "until": until,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RecoverOut,
                    parse_obj_as(
                        type_=RecoverOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawEventsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_messages(
        self,
        *,
        event_types: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[MessageOut]]:
        """
        Get event messages for the current organization.

        Args:
            ctx: The API context containing organization info.
            event_types: Optional list of event types to filter by.

        Returns:
            List of event messages.

        Parameters
        ----------
        event_types : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[MessageOut]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "events/messages",
            method="GET",
            params={
                "event_types": event_types,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[MessageOut],
                    parse_obj_as(
                        type_=typing.List[MessageOut],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_message(
        self, message_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[MessageOut]:
        """
        Get a specific event message by ID.

        Args:
            message_id: The ID of the message to retrieve.
            ctx: The API context containing organization info.

        Returns:
            The event message with its payload.

        Parameters
        ----------
        message_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[MessageOut]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"events/messages/{jsonable_encoder(message_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MessageOut,
                    parse_obj_as(
                        type_=MessageOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_message_attempts(
        self, message_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[MessageAttemptOut]]:
        """
        Get delivery attempts for a specific message.

        Args:
            message_id: The ID of the message.
            ctx: The API context containing organization info.

        Returns:
            List of delivery attempts for this message.

        Parameters
        ----------
        message_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[MessageAttemptOut]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"events/messages/{jsonable_encoder(message_id)}/attempts",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[MessageAttemptOut],
                    parse_obj_as(
                        type_=typing.List[MessageAttemptOut],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_subscriptions(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[EndpointOut]]:
        """
        Get all webhook subscriptions for the current organization.

        Args:
            ctx: The API context containing organization info.

        Returns:
            List of webhook subscriptions.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[EndpointOut]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "events/subscriptions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[EndpointOut],
                    parse_obj_as(
                        type_=typing.List[EndpointOut],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_subscription(
        self,
        *,
        url: str,
        event_types: typing.Sequence[EventType],
        secret: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EndpointOut]:
        """
        Create a new webhook subscription.

        Args:
            request: The subscription creation request.
            ctx: The API context containing organization info.

        Returns:
            The created subscription.

        Parameters
        ----------
        url : str

        event_types : typing.Sequence[EventType]

        secret : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EndpointOut]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "events/subscriptions",
            method="POST",
            json={
                "url": url,
                "event_types": event_types,
                "secret": secret,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EndpointOut,
                    parse_obj_as(
                        type_=EndpointOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_subscription(
        self, subscription_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SubscriptionWithAttemptsOut]:
        """
        Get a specific webhook subscription with its delivery attempts.

        Args:
            subscription_id: The ID of the subscription to retrieve.
            ctx: The API context containing organization info.

        Returns:
            The subscription details with message delivery attempts.

        Parameters
        ----------
        subscription_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SubscriptionWithAttemptsOut]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SubscriptionWithAttemptsOut,
                    parse_obj_as(
                        type_=SubscriptionWithAttemptsOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_subscription(
        self, subscription_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Delete a webhook subscription.

        Args:
            subscription_id: The ID of the subscription to delete.
            ctx: The API context containing organization info.

        Parameters
        ----------
        subscription_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def patch_subscription(
        self,
        subscription_id: str,
        *,
        url: typing.Optional[str] = OMIT,
        event_types: typing.Optional[typing.Sequence[EventType]] = OMIT,
        disabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EndpointOut]:
        """
        Update a webhook subscription.

        Args:
            subscription_id: The ID of the subscription to update.
            request: The subscription update request.
            ctx: The API context containing organization info.

        Returns:
            The updated subscription.

        Parameters
        ----------
        subscription_id : str

        url : typing.Optional[str]

        event_types : typing.Optional[typing.Sequence[EventType]]

        disabled : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EndpointOut]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}",
            method="PATCH",
            json={
                "url": url,
                "event_types": event_types,
                "disabled": disabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EndpointOut,
                    parse_obj_as(
                        type_=EndpointOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def enable_subscription(
        self,
        subscription_id: str,
        *,
        request: typing.Optional[EnableEndpointRequest] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EndpointOut]:
        """
        Enable a disabled webhook subscription, optionally recovering failed messages.

        Args:
            subscription_id: The ID of the subscription to enable.
            request: Optional request with recovery time range.
            ctx: The API context containing organization info.

        Returns:
            The enabled subscription.

        Parameters
        ----------
        subscription_id : str

        request : typing.Optional[EnableEndpointRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EndpointOut]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}/enable",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=EnableEndpointRequest, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EndpointOut,
                    parse_obj_as(
                        type_=EndpointOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_subscription_secret(
        self, subscription_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[EndpointSecretOut]:
        """
        Get the signing secret for a webhook subscription.

        Args:
            subscription_id: The ID of the subscription.
            ctx: The API context containing organization info.

        Returns:
            The subscription's signing secret.

        Parameters
        ----------
        subscription_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EndpointSecretOut]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}/secret",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EndpointSecretOut,
                    parse_obj_as(
                        type_=EndpointSecretOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def recover_failed_messages(
        self,
        subscription_id: str,
        *,
        since: dt.datetime,
        until: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RecoverOut]:
        """
        Recover (retry) failed messages for a webhook subscription.

        This endpoint triggers a recovery of all failed messages since the specified
        time. Useful after re-enabling a disabled endpoint to retry messages that
        failed while the endpoint was down.

        Args:
            subscription_id: The ID of the subscription to recover messages for.
            request: The recovery request with time range.
            ctx: The API context containing organization info.

        Returns:
            Information about the recovery task.

        Parameters
        ----------
        subscription_id : str

        since : dt.datetime

        until : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RecoverOut]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"events/subscriptions/{jsonable_encoder(subscription_id)}/recover",
            method="POST",
            json={
                "since": since,
                "until": until,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RecoverOut,
                    parse_obj_as(
                        type_=RecoverOut,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
