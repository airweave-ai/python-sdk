# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.not_found_error import NotFoundError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.event_type import EventType
from ..types.not_found_error_response import NotFoundErrorResponse
from ..types.rate_limit_error_response import RateLimitErrorResponse
from ..types.recovery_task import RecoveryTask
from ..types.webhook_message import WebhookMessage
from ..types.webhook_message_with_attempts import WebhookMessageWithAttempts
from ..types.webhook_subscription import WebhookSubscription
from ..types.webhook_subscription_detail import WebhookSubscriptionDetail

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawWebhooksClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_messages(
        self,
        *,
        event_types: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[WebhookMessage]]:
        """
        Retrieve all webhook messages for your organization.

        Webhook messages represent payloads that were sent (or attempted to be sent)
        to your subscribed endpoints. Each message contains the event type, payload data,
        and delivery status information.

        Use the `event_types` query parameter to filter messages by specific event types,
        such as `sync.completed` or `sync.failed`.

        Parameters
        ----------
        event_types : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter messages by event type(s). Accepts multiple values, e.g., `?event_types=sync.completed&event_types=sync.failed`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[WebhookMessage]]
            List of webhook messages
        """
        _response = self._client_wrapper.httpx_client.request(
            "webhooks/messages",
            method="GET",
            params={
                "event_types": event_types,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WebhookMessage],
                    parse_obj_as(
                        type_=typing.List[WebhookMessage],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_message(
        self,
        message_id: str,
        *,
        include_attempts: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WebhookMessageWithAttempts]:
        """
        Retrieve a specific webhook message by its ID.

        Returns the full message details including the event type, payload data,
        timestamp, and delivery channel information. Use this to inspect the
        exact payload that was sent to your webhook endpoints.

        Use `include_attempts=true` to also retrieve delivery attempts for this message,
        which include HTTP response codes, response bodies, and timestamps for debugging
        delivery failures.

        Parameters
        ----------
        message_id : str
            The unique identifier of the message to retrieve (UUID).

        include_attempts : typing.Optional[bool]
            Include delivery attempts for this message. Each attempt includes the HTTP response code, response body, and timestamp.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WebhookMessageWithAttempts]
            Webhook message details
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/messages/{jsonable_encoder(message_id)}",
            method="GET",
            params={
                "include_attempts": include_attempts,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WebhookMessageWithAttempts,
                    parse_obj_as(
                        type_=WebhookMessageWithAttempts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_subscriptions(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[WebhookSubscription]]:
        """
        List all webhook subscriptions for your organization.

        Returns all configured webhook endpoints, including their URLs, subscribed
        event types, and current status (enabled/disabled). Use this to audit
        your webhook configuration or find a specific subscription.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[WebhookSubscription]]
            List of webhook subscriptions
        """
        _response = self._client_wrapper.httpx_client.request(
            "webhooks/subscriptions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WebhookSubscription],
                    parse_obj_as(
                        type_=typing.List[WebhookSubscription],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_subscription(
        self,
        *,
        url: str,
        event_types: typing.Sequence[EventType],
        secret: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WebhookSubscription]:
        """
        Create a new webhook subscription.

        Webhook subscriptions allow you to receive real-time notifications when events
        occur in Airweave. When you create a subscription, you specify:

        - **URL**: The HTTPS endpoint where events will be delivered
        - **Event Types**: Which events you want to receive (e.g., `sync.completed`, `sync.failed`)
        - **Secret** (optional): A custom signing secret for verifying webhook signatures

        After creation, Airweave will send HTTP POST requests to your URL whenever
        matching events occur. Each request includes a signature header for verification.

        Parameters
        ----------
        url : str
            The HTTPS URL where webhook events will be delivered. Must be a publicly accessible endpoint that returns a 2xx status code.

        event_types : typing.Sequence[EventType]
            List of event types to subscribe to. Events not in this list will not be delivered to this subscription. Available types: `sync.pending`, `sync.running`, `sync.completed`, `sync.failed`, `sync.cancelled`, `source_connection.created`, `source_connection.auth_completed`, `source_connection.deleted`, `collection.created`, `collection.updated`, `collection.deleted`.

        secret : typing.Optional[str]
            Optional custom signing secret for webhook signature verification. If not provided, a secure secret will be auto-generated. Must be at least 24 characters if specified.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WebhookSubscription]
            Created subscription
        """
        _response = self._client_wrapper.httpx_client.request(
            "webhooks/subscriptions",
            method="POST",
            json={
                "url": url,
                "event_types": event_types,
                "secret": secret,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WebhookSubscription,
                    parse_obj_as(
                        type_=WebhookSubscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_subscription(
        self,
        subscription_id: str,
        *,
        include_secret: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WebhookSubscriptionDetail]:
        """
        Retrieve a specific webhook subscription with its recent delivery attempts.

        Returns the subscription configuration along with a history of message delivery
        attempts. This is useful for debugging delivery issues or verifying that your
        endpoint is correctly receiving events.

        Use `include_secret=true` to also retrieve the signing secret for webhook
        signature verification. Keep this secret secure.

        Parameters
        ----------
        subscription_id : str
            The unique identifier of the subscription to retrieve (UUID).

        include_secret : typing.Optional[bool]
            Include the signing secret for webhook signature verification. Keep this secret secure and use it to verify the 'svix-signature' header.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WebhookSubscriptionDetail]
            Subscription with delivery attempts
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/subscriptions/{jsonable_encoder(subscription_id)}",
            method="GET",
            params={
                "include_secret": include_secret,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WebhookSubscriptionDetail,
                    parse_obj_as(
                        type_=WebhookSubscriptionDetail,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_subscription(
        self, subscription_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WebhookSubscription]:
        """
        Permanently delete a webhook subscription.

        Once deleted, Airweave will stop sending events to this endpoint immediately.
        This action cannot be undone. Any pending message deliveries will be cancelled.

        If you want to temporarily stop receiving events, consider disabling the
        subscription instead using the PATCH endpoint.

        Parameters
        ----------
        subscription_id : str
            The unique identifier of the subscription to delete (UUID).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WebhookSubscription]
            Deleted subscription
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/subscriptions/{jsonable_encoder(subscription_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WebhookSubscription,
                    parse_obj_as(
                        type_=WebhookSubscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def patch_subscription(
        self,
        subscription_id: str,
        *,
        url: typing.Optional[str] = OMIT,
        event_types: typing.Optional[typing.Sequence[EventType]] = OMIT,
        disabled: typing.Optional[bool] = OMIT,
        recover_since: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WebhookSubscription]:
        """
        Update an existing webhook subscription.

        Use this endpoint to modify a subscription's configuration. You can:

        - **Change the URL**: Update where events are delivered
        - **Update event types**: Modify which events trigger notifications
        - **Enable/disable**: Temporarily pause delivery without deleting the subscription
        - **Recover messages**: When re-enabling, optionally recover missed messages

        Only include the fields you want to change. Omitted fields will retain their
        current values.

        When re-enabling a subscription (`disabled: false`), you can optionally provide
        `recover_since` to automatically retry all messages that were generated while
        the subscription was disabled.

        Parameters
        ----------
        subscription_id : str
            The unique identifier of the subscription to update (UUID).

        url : typing.Optional[str]
            New URL for webhook delivery. Must be a publicly accessible HTTPS endpoint.

        event_types : typing.Optional[typing.Sequence[EventType]]
            New list of event types to subscribe to. This replaces the existing list entirely.

        disabled : typing.Optional[bool]
            Set to `true` to pause delivery to this subscription, or `false` to resume. Disabled subscriptions will not receive events.

        recover_since : typing.Optional[dt.datetime]
            When re-enabling a subscription (`disabled: false`), optionally recover failed messages from this timestamp. Only applies when enabling.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WebhookSubscription]
            Updated subscription
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/subscriptions/{jsonable_encoder(subscription_id)}",
            method="PATCH",
            json={
                "url": url,
                "event_types": event_types,
                "disabled": disabled,
                "recover_since": recover_since,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WebhookSubscription,
                    parse_obj_as(
                        type_=WebhookSubscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def recover_failed_messages(
        self,
        subscription_id: str,
        *,
        since: dt.datetime,
        until: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RecoveryTask]:
        """
        Retry failed message deliveries for a webhook subscription.

        Triggers a recovery process that replays all failed messages within the
        specified time window. This is useful when:

        - Your endpoint was temporarily down and you want to catch up
        - You've fixed a bug in your webhook handler
        - You want to reprocess events after re-enabling a disabled subscription

        Messages are retried in chronological order. Successfully delivered messages
        are skipped; only failed or pending messages are retried.

        Parameters
        ----------
        subscription_id : str
            The unique identifier of the subscription to recover messages for (UUID).

        since : dt.datetime
            Start of the recovery time window (inclusive). All failed messages from this time onward will be retried.

        until : typing.Optional[dt.datetime]
            End of the recovery time window (exclusive). If not specified, recovers all failed messages up to now.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RecoveryTask]
            Recovery task information
        """
        _response = self._client_wrapper.httpx_client.request(
            f"webhooks/subscriptions/{jsonable_encoder(subscription_id)}/recover",
            method="POST",
            json={
                "since": since,
                "until": until,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RecoveryTask,
                    parse_obj_as(
                        type_=RecoveryTask,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawWebhooksClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_messages(
        self,
        *,
        event_types: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[WebhookMessage]]:
        """
        Retrieve all webhook messages for your organization.

        Webhook messages represent payloads that were sent (or attempted to be sent)
        to your subscribed endpoints. Each message contains the event type, payload data,
        and delivery status information.

        Use the `event_types` query parameter to filter messages by specific event types,
        such as `sync.completed` or `sync.failed`.

        Parameters
        ----------
        event_types : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter messages by event type(s). Accepts multiple values, e.g., `?event_types=sync.completed&event_types=sync.failed`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[WebhookMessage]]
            List of webhook messages
        """
        _response = await self._client_wrapper.httpx_client.request(
            "webhooks/messages",
            method="GET",
            params={
                "event_types": event_types,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WebhookMessage],
                    parse_obj_as(
                        type_=typing.List[WebhookMessage],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_message(
        self,
        message_id: str,
        *,
        include_attempts: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WebhookMessageWithAttempts]:
        """
        Retrieve a specific webhook message by its ID.

        Returns the full message details including the event type, payload data,
        timestamp, and delivery channel information. Use this to inspect the
        exact payload that was sent to your webhook endpoints.

        Use `include_attempts=true` to also retrieve delivery attempts for this message,
        which include HTTP response codes, response bodies, and timestamps for debugging
        delivery failures.

        Parameters
        ----------
        message_id : str
            The unique identifier of the message to retrieve (UUID).

        include_attempts : typing.Optional[bool]
            Include delivery attempts for this message. Each attempt includes the HTTP response code, response body, and timestamp.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WebhookMessageWithAttempts]
            Webhook message details
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/messages/{jsonable_encoder(message_id)}",
            method="GET",
            params={
                "include_attempts": include_attempts,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WebhookMessageWithAttempts,
                    parse_obj_as(
                        type_=WebhookMessageWithAttempts,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_subscriptions(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[WebhookSubscription]]:
        """
        List all webhook subscriptions for your organization.

        Returns all configured webhook endpoints, including their URLs, subscribed
        event types, and current status (enabled/disabled). Use this to audit
        your webhook configuration or find a specific subscription.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[WebhookSubscription]]
            List of webhook subscriptions
        """
        _response = await self._client_wrapper.httpx_client.request(
            "webhooks/subscriptions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WebhookSubscription],
                    parse_obj_as(
                        type_=typing.List[WebhookSubscription],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_subscription(
        self,
        *,
        url: str,
        event_types: typing.Sequence[EventType],
        secret: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WebhookSubscription]:
        """
        Create a new webhook subscription.

        Webhook subscriptions allow you to receive real-time notifications when events
        occur in Airweave. When you create a subscription, you specify:

        - **URL**: The HTTPS endpoint where events will be delivered
        - **Event Types**: Which events you want to receive (e.g., `sync.completed`, `sync.failed`)
        - **Secret** (optional): A custom signing secret for verifying webhook signatures

        After creation, Airweave will send HTTP POST requests to your URL whenever
        matching events occur. Each request includes a signature header for verification.

        Parameters
        ----------
        url : str
            The HTTPS URL where webhook events will be delivered. Must be a publicly accessible endpoint that returns a 2xx status code.

        event_types : typing.Sequence[EventType]
            List of event types to subscribe to. Events not in this list will not be delivered to this subscription. Available types: `sync.pending`, `sync.running`, `sync.completed`, `sync.failed`, `sync.cancelled`, `source_connection.created`, `source_connection.auth_completed`, `source_connection.deleted`, `collection.created`, `collection.updated`, `collection.deleted`.

        secret : typing.Optional[str]
            Optional custom signing secret for webhook signature verification. If not provided, a secure secret will be auto-generated. Must be at least 24 characters if specified.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WebhookSubscription]
            Created subscription
        """
        _response = await self._client_wrapper.httpx_client.request(
            "webhooks/subscriptions",
            method="POST",
            json={
                "url": url,
                "event_types": event_types,
                "secret": secret,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WebhookSubscription,
                    parse_obj_as(
                        type_=WebhookSubscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_subscription(
        self,
        subscription_id: str,
        *,
        include_secret: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WebhookSubscriptionDetail]:
        """
        Retrieve a specific webhook subscription with its recent delivery attempts.

        Returns the subscription configuration along with a history of message delivery
        attempts. This is useful for debugging delivery issues or verifying that your
        endpoint is correctly receiving events.

        Use `include_secret=true` to also retrieve the signing secret for webhook
        signature verification. Keep this secret secure.

        Parameters
        ----------
        subscription_id : str
            The unique identifier of the subscription to retrieve (UUID).

        include_secret : typing.Optional[bool]
            Include the signing secret for webhook signature verification. Keep this secret secure and use it to verify the 'svix-signature' header.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WebhookSubscriptionDetail]
            Subscription with delivery attempts
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/subscriptions/{jsonable_encoder(subscription_id)}",
            method="GET",
            params={
                "include_secret": include_secret,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WebhookSubscriptionDetail,
                    parse_obj_as(
                        type_=WebhookSubscriptionDetail,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_subscription(
        self, subscription_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WebhookSubscription]:
        """
        Permanently delete a webhook subscription.

        Once deleted, Airweave will stop sending events to this endpoint immediately.
        This action cannot be undone. Any pending message deliveries will be cancelled.

        If you want to temporarily stop receiving events, consider disabling the
        subscription instead using the PATCH endpoint.

        Parameters
        ----------
        subscription_id : str
            The unique identifier of the subscription to delete (UUID).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WebhookSubscription]
            Deleted subscription
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/subscriptions/{jsonable_encoder(subscription_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WebhookSubscription,
                    parse_obj_as(
                        type_=WebhookSubscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def patch_subscription(
        self,
        subscription_id: str,
        *,
        url: typing.Optional[str] = OMIT,
        event_types: typing.Optional[typing.Sequence[EventType]] = OMIT,
        disabled: typing.Optional[bool] = OMIT,
        recover_since: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WebhookSubscription]:
        """
        Update an existing webhook subscription.

        Use this endpoint to modify a subscription's configuration. You can:

        - **Change the URL**: Update where events are delivered
        - **Update event types**: Modify which events trigger notifications
        - **Enable/disable**: Temporarily pause delivery without deleting the subscription
        - **Recover messages**: When re-enabling, optionally recover missed messages

        Only include the fields you want to change. Omitted fields will retain their
        current values.

        When re-enabling a subscription (`disabled: false`), you can optionally provide
        `recover_since` to automatically retry all messages that were generated while
        the subscription was disabled.

        Parameters
        ----------
        subscription_id : str
            The unique identifier of the subscription to update (UUID).

        url : typing.Optional[str]
            New URL for webhook delivery. Must be a publicly accessible HTTPS endpoint.

        event_types : typing.Optional[typing.Sequence[EventType]]
            New list of event types to subscribe to. This replaces the existing list entirely.

        disabled : typing.Optional[bool]
            Set to `true` to pause delivery to this subscription, or `false` to resume. Disabled subscriptions will not receive events.

        recover_since : typing.Optional[dt.datetime]
            When re-enabling a subscription (`disabled: false`), optionally recover failed messages from this timestamp. Only applies when enabling.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WebhookSubscription]
            Updated subscription
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/subscriptions/{jsonable_encoder(subscription_id)}",
            method="PATCH",
            json={
                "url": url,
                "event_types": event_types,
                "disabled": disabled,
                "recover_since": recover_since,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WebhookSubscription,
                    parse_obj_as(
                        type_=WebhookSubscription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def recover_failed_messages(
        self,
        subscription_id: str,
        *,
        since: dt.datetime,
        until: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RecoveryTask]:
        """
        Retry failed message deliveries for a webhook subscription.

        Triggers a recovery process that replays all failed messages within the
        specified time window. This is useful when:

        - Your endpoint was temporarily down and you want to catch up
        - You've fixed a bug in your webhook handler
        - You want to reprocess events after re-enabling a disabled subscription

        Messages are retried in chronological order. Successfully delivered messages
        are skipped; only failed or pending messages are retried.

        Parameters
        ----------
        subscription_id : str
            The unique identifier of the subscription to recover messages for (UUID).

        since : dt.datetime
            Start of the recovery time window (inclusive). All failed messages from this time onward will be retried.

        until : typing.Optional[dt.datetime]
            End of the recovery time window (exclusive). If not specified, recovers all failed messages up to now.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RecoveryTask]
            Recovery task information
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"webhooks/subscriptions/{jsonable_encoder(subscription_id)}/recover",
            method="POST",
            json={
                "since": since,
                "until": until,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RecoveryTask,
                    parse_obj_as(
                        type_=RecoveryTask,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFoundErrorResponse,
                        parse_obj_as(
                            type_=NotFoundErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        RateLimitErrorResponse,
                        parse_obj_as(
                            type_=RateLimitErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
